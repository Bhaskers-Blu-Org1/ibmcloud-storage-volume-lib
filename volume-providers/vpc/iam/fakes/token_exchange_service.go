// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"github.com/IBM/ibmcloud-storage-volume-lib/volume-providers/vpc/iam"
	"go.uber.org/zap"
)

type TokenExchangeService struct {
	ExchangeRefreshTokenForAccessTokenStub        func(ctx context.Context, refreshToken string, logger *zap.Logger) (*iam.AccessToken, error)
	exchangeRefreshTokenForAccessTokenMutex       sync.RWMutex
	exchangeRefreshTokenForAccessTokenArgsForCall []struct {
		ctx          context.Context
		refreshToken string
		logger       *zap.Logger
	}
	exchangeRefreshTokenForAccessTokenReturns struct {
		result1 *iam.AccessToken
		result2 error
	}
	exchangeRefreshTokenForAccessTokenReturnsOnCall map[int]struct {
		result1 *iam.AccessToken
		result2 error
	}
	ExchangeAccessTokenForIMSTokenStub        func(ctx context.Context, accessToken iam.AccessToken, logger *zap.Logger) (*iam.IMSToken, error)
	exchangeAccessTokenForIMSTokenMutex       sync.RWMutex
	exchangeAccessTokenForIMSTokenArgsForCall []struct {
		ctx         context.Context
		accessToken iam.AccessToken
		logger      *zap.Logger
	}
	exchangeAccessTokenForIMSTokenReturns struct {
		result1 *iam.IMSToken
		result2 error
	}
	exchangeAccessTokenForIMSTokenReturnsOnCall map[int]struct {
		result1 *iam.IMSToken
		result2 error
	}
	ExchangeIAMAPIKeyForIMSTokenStub        func(ctx context.Context, iamAPIKey string, logger *zap.Logger) (*iam.IMSToken, error)
	exchangeIAMAPIKeyForIMSTokenMutex       sync.RWMutex
	exchangeIAMAPIKeyForIMSTokenArgsForCall []struct {
		ctx       context.Context
		iamAPIKey string
		logger    *zap.Logger
	}
	exchangeIAMAPIKeyForIMSTokenReturns struct {
		result1 *iam.IMSToken
		result2 error
	}
	exchangeIAMAPIKeyForIMSTokenReturnsOnCall map[int]struct {
		result1 *iam.IMSToken
		result2 error
	}
	ExchangeIAMAPIKeyForAccessTokenStub        func(ctx context.Context, iamAPIKey string, logger *zap.Logger) (*iam.AccessToken, error)
	exchangeIAMAPIKeyForAccessTokenMutex       sync.RWMutex
	exchangeIAMAPIKeyForAccessTokenArgsForCall []struct {
		ctx       context.Context
		iamAPIKey string
		logger    *zap.Logger
	}
	exchangeIAMAPIKeyForAccessTokenReturns struct {
		result1 *iam.AccessToken
		result2 error
	}
	exchangeIAMAPIKeyForAccessTokenReturnsOnCall map[int]struct {
		result1 *iam.AccessToken
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessToken(ctx context.Context, refreshToken string, logger *zap.Logger) (*iam.AccessToken, error) {
	fake.exchangeRefreshTokenForAccessTokenMutex.Lock()
	ret, specificReturn := fake.exchangeRefreshTokenForAccessTokenReturnsOnCall[len(fake.exchangeRefreshTokenForAccessTokenArgsForCall)]
	fake.exchangeRefreshTokenForAccessTokenArgsForCall = append(fake.exchangeRefreshTokenForAccessTokenArgsForCall, struct {
		ctx          context.Context
		refreshToken string
		logger       *zap.Logger
	}{ctx, refreshToken, logger})
	fake.recordInvocation("ExchangeRefreshTokenForAccessToken", []interface{}{ctx, refreshToken, logger})
	fake.exchangeRefreshTokenForAccessTokenMutex.Unlock()
	if fake.ExchangeRefreshTokenForAccessTokenStub != nil {
		return fake.ExchangeRefreshTokenForAccessTokenStub(ctx, refreshToken, logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.exchangeRefreshTokenForAccessTokenReturns.result1, fake.exchangeRefreshTokenForAccessTokenReturns.result2
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenCallCount() int {
	fake.exchangeRefreshTokenForAccessTokenMutex.RLock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.RUnlock()
	return len(fake.exchangeRefreshTokenForAccessTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenArgsForCall(i int) (context.Context, string, *zap.Logger) {
	fake.exchangeRefreshTokenForAccessTokenMutex.RLock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.RUnlock()
	return fake.exchangeRefreshTokenForAccessTokenArgsForCall[i].ctx, fake.exchangeRefreshTokenForAccessTokenArgsForCall[i].refreshToken, fake.exchangeRefreshTokenForAccessTokenArgsForCall[i].logger
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenReturns(result1 *iam.AccessToken, result2 error) {
	fake.ExchangeRefreshTokenForAccessTokenStub = nil
	fake.exchangeRefreshTokenForAccessTokenReturns = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeRefreshTokenForAccessTokenReturnsOnCall(i int, result1 *iam.AccessToken, result2 error) {
	fake.ExchangeRefreshTokenForAccessTokenStub = nil
	if fake.exchangeRefreshTokenForAccessTokenReturnsOnCall == nil {
		fake.exchangeRefreshTokenForAccessTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.AccessToken
			result2 error
		})
	}
	fake.exchangeRefreshTokenForAccessTokenReturnsOnCall[i] = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSToken(ctx context.Context, accessToken iam.AccessToken, logger *zap.Logger) (*iam.IMSToken, error) {
	fake.exchangeAccessTokenForIMSTokenMutex.Lock()
	ret, specificReturn := fake.exchangeAccessTokenForIMSTokenReturnsOnCall[len(fake.exchangeAccessTokenForIMSTokenArgsForCall)]
	fake.exchangeAccessTokenForIMSTokenArgsForCall = append(fake.exchangeAccessTokenForIMSTokenArgsForCall, struct {
		ctx         context.Context
		accessToken iam.AccessToken
		logger      *zap.Logger
	}{ctx, accessToken, logger})
	fake.recordInvocation("ExchangeAccessTokenForIMSToken", []interface{}{ctx, accessToken, logger})
	fake.exchangeAccessTokenForIMSTokenMutex.Unlock()
	if fake.ExchangeAccessTokenForIMSTokenStub != nil {
		return fake.ExchangeAccessTokenForIMSTokenStub(ctx, accessToken, logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.exchangeAccessTokenForIMSTokenReturns.result1, fake.exchangeAccessTokenForIMSTokenReturns.result2
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenCallCount() int {
	fake.exchangeAccessTokenForIMSTokenMutex.RLock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.RUnlock()
	return len(fake.exchangeAccessTokenForIMSTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenArgsForCall(i int) (context.Context, iam.AccessToken, *zap.Logger) {
	fake.exchangeAccessTokenForIMSTokenMutex.RLock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.RUnlock()
	return fake.exchangeAccessTokenForIMSTokenArgsForCall[i].ctx, fake.exchangeAccessTokenForIMSTokenArgsForCall[i].accessToken, fake.exchangeAccessTokenForIMSTokenArgsForCall[i].logger
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenReturns(result1 *iam.IMSToken, result2 error) {
	fake.ExchangeAccessTokenForIMSTokenStub = nil
	fake.exchangeAccessTokenForIMSTokenReturns = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeAccessTokenForIMSTokenReturnsOnCall(i int, result1 *iam.IMSToken, result2 error) {
	fake.ExchangeAccessTokenForIMSTokenStub = nil
	if fake.exchangeAccessTokenForIMSTokenReturnsOnCall == nil {
		fake.exchangeAccessTokenForIMSTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.IMSToken
			result2 error
		})
	}
	fake.exchangeAccessTokenForIMSTokenReturnsOnCall[i] = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSToken(ctx context.Context, iamAPIKey string, logger *zap.Logger) (*iam.IMSToken, error) {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.Lock()
	ret, specificReturn := fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall[len(fake.exchangeIAMAPIKeyForIMSTokenArgsForCall)]
	fake.exchangeIAMAPIKeyForIMSTokenArgsForCall = append(fake.exchangeIAMAPIKeyForIMSTokenArgsForCall, struct {
		ctx       context.Context
		iamAPIKey string
		logger    *zap.Logger
	}{ctx, iamAPIKey, logger})
	fake.recordInvocation("ExchangeIAMAPIKeyForIMSToken", []interface{}{ctx, iamAPIKey, logger})
	fake.exchangeIAMAPIKeyForIMSTokenMutex.Unlock()
	if fake.ExchangeIAMAPIKeyForIMSTokenStub != nil {
		return fake.ExchangeIAMAPIKeyForIMSTokenStub(ctx, iamAPIKey, logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.exchangeIAMAPIKeyForIMSTokenReturns.result1, fake.exchangeIAMAPIKeyForIMSTokenReturns.result2
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenCallCount() int {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.RUnlock()
	return len(fake.exchangeIAMAPIKeyForIMSTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenArgsForCall(i int) (context.Context, string, *zap.Logger) {
	fake.exchangeIAMAPIKeyForIMSTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.RUnlock()
	return fake.exchangeIAMAPIKeyForIMSTokenArgsForCall[i].ctx, fake.exchangeIAMAPIKeyForIMSTokenArgsForCall[i].iamAPIKey, fake.exchangeIAMAPIKeyForIMSTokenArgsForCall[i].logger
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenReturns(result1 *iam.IMSToken, result2 error) {
	fake.ExchangeIAMAPIKeyForIMSTokenStub = nil
	fake.exchangeIAMAPIKeyForIMSTokenReturns = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForIMSTokenReturnsOnCall(i int, result1 *iam.IMSToken, result2 error) {
	fake.ExchangeIAMAPIKeyForIMSTokenStub = nil
	if fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall == nil {
		fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.IMSToken
			result2 error
		})
	}
	fake.exchangeIAMAPIKeyForIMSTokenReturnsOnCall[i] = struct {
		result1 *iam.IMSToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessToken(ctx context.Context, iamAPIKey string, logger *zap.Logger) (*iam.AccessToken, error) {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.Lock()
	ret, specificReturn := fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall[len(fake.exchangeIAMAPIKeyForAccessTokenArgsForCall)]
	fake.exchangeIAMAPIKeyForAccessTokenArgsForCall = append(fake.exchangeIAMAPIKeyForAccessTokenArgsForCall, struct {
		ctx       context.Context
		iamAPIKey string
		logger    *zap.Logger
	}{ctx, iamAPIKey, logger})
	fake.recordInvocation("ExchangeIAMAPIKeyForAccessToken", []interface{}{ctx, iamAPIKey, logger})
	fake.exchangeIAMAPIKeyForAccessTokenMutex.Unlock()
	if fake.ExchangeIAMAPIKeyForAccessTokenStub != nil {
		return fake.ExchangeIAMAPIKeyForAccessTokenStub(ctx, iamAPIKey, logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.exchangeIAMAPIKeyForAccessTokenReturns.result1, fake.exchangeIAMAPIKeyForAccessTokenReturns.result2
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenCallCount() int {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.RUnlock()
	return len(fake.exchangeIAMAPIKeyForAccessTokenArgsForCall)
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenArgsForCall(i int) (context.Context, string, *zap.Logger) {
	fake.exchangeIAMAPIKeyForAccessTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.RUnlock()
	return fake.exchangeIAMAPIKeyForAccessTokenArgsForCall[i].ctx, fake.exchangeIAMAPIKeyForAccessTokenArgsForCall[i].iamAPIKey, fake.exchangeIAMAPIKeyForAccessTokenArgsForCall[i].logger
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenReturns(result1 *iam.AccessToken, result2 error) {
	fake.ExchangeIAMAPIKeyForAccessTokenStub = nil
	fake.exchangeIAMAPIKeyForAccessTokenReturns = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) ExchangeIAMAPIKeyForAccessTokenReturnsOnCall(i int, result1 *iam.AccessToken, result2 error) {
	fake.ExchangeIAMAPIKeyForAccessTokenStub = nil
	if fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall == nil {
		fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall = make(map[int]struct {
			result1 *iam.AccessToken
			result2 error
		})
	}
	fake.exchangeIAMAPIKeyForAccessTokenReturnsOnCall[i] = struct {
		result1 *iam.AccessToken
		result2 error
	}{result1, result2}
}

func (fake *TokenExchangeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.exchangeRefreshTokenForAccessTokenMutex.RLock()
	defer fake.exchangeRefreshTokenForAccessTokenMutex.RUnlock()
	fake.exchangeAccessTokenForIMSTokenMutex.RLock()
	defer fake.exchangeAccessTokenForIMSTokenMutex.RUnlock()
	fake.exchangeIAMAPIKeyForIMSTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForIMSTokenMutex.RUnlock()
	fake.exchangeIAMAPIKeyForAccessTokenMutex.RLock()
	defer fake.exchangeIAMAPIKeyForAccessTokenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TokenExchangeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ iam.TokenExchangeService = new(TokenExchangeService)
