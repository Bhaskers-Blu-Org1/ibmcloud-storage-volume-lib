// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"

	"github.com/IBM/ibmcloud-storage-volume-lib/volume-providers/vpc/vpcclient/client"
)

type SessionClient struct {
	NewRequestStub        func(operation *client.Operation) *client.Request
	newRequestMutex       sync.RWMutex
	newRequestArgsForCall []struct {
		operation *client.Operation
	}
	newRequestReturns struct {
		result1 *client.Request
	}
	newRequestReturnsOnCall map[int]struct {
		result1 *client.Request
	}
	WithDebugStub        func(writer io.Writer) client.SessionClient
	withDebugMutex       sync.RWMutex
	withDebugArgsForCall []struct {
		writer io.Writer
	}
	withDebugReturns struct {
		result1 client.SessionClient
	}
	withDebugReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	WithAuthTokenStub        func(authToken string) client.SessionClient
	withAuthTokenMutex       sync.RWMutex
	withAuthTokenArgsForCall []struct {
		authToken string
	}
	withAuthTokenReturns struct {
		result1 client.SessionClient
	}
	withAuthTokenReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	WithPathParameterStub        func(name, value string) client.SessionClient
	withPathParameterMutex       sync.RWMutex
	withPathParameterArgsForCall []struct {
		name  string
		value string
	}
	withPathParameterReturns struct {
		result1 client.SessionClient
	}
	withPathParameterReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	WithQueryValueStub        func(name, value string) client.SessionClient
	withQueryValueMutex       sync.RWMutex
	withQueryValueArgsForCall []struct {
		name  string
		value string
	}
	withQueryValueReturns struct {
		result1 client.SessionClient
	}
	withQueryValueReturnsOnCall map[int]struct {
		result1 client.SessionClient
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *SessionClient) NewRequest(operation *client.Operation) *client.Request {
	fake.newRequestMutex.Lock()
	ret, specificReturn := fake.newRequestReturnsOnCall[len(fake.newRequestArgsForCall)]
	fake.newRequestArgsForCall = append(fake.newRequestArgsForCall, struct {
		operation *client.Operation
	}{operation})
	fake.recordInvocation("NewRequest", []interface{}{operation})
	fake.newRequestMutex.Unlock()
	if fake.NewRequestStub != nil {
		return fake.NewRequestStub(operation)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newRequestReturns.result1
}

func (fake *SessionClient) NewRequestCallCount() int {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	return len(fake.newRequestArgsForCall)
}

func (fake *SessionClient) NewRequestArgsForCall(i int) *client.Operation {
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	return fake.newRequestArgsForCall[i].operation
}

func (fake *SessionClient) NewRequestReturns(result1 *client.Request) {
	fake.NewRequestStub = nil
	fake.newRequestReturns = struct {
		result1 *client.Request
	}{result1}
}

func (fake *SessionClient) NewRequestReturnsOnCall(i int, result1 *client.Request) {
	fake.NewRequestStub = nil
	if fake.newRequestReturnsOnCall == nil {
		fake.newRequestReturnsOnCall = make(map[int]struct {
			result1 *client.Request
		})
	}
	fake.newRequestReturnsOnCall[i] = struct {
		result1 *client.Request
	}{result1}
}

func (fake *SessionClient) WithDebug(writer io.Writer) client.SessionClient {
	fake.withDebugMutex.Lock()
	ret, specificReturn := fake.withDebugReturnsOnCall[len(fake.withDebugArgsForCall)]
	fake.withDebugArgsForCall = append(fake.withDebugArgsForCall, struct {
		writer io.Writer
	}{writer})
	fake.recordInvocation("WithDebug", []interface{}{writer})
	fake.withDebugMutex.Unlock()
	if fake.WithDebugStub != nil {
		return fake.WithDebugStub(writer)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.withDebugReturns.result1
}

func (fake *SessionClient) WithDebugCallCount() int {
	fake.withDebugMutex.RLock()
	defer fake.withDebugMutex.RUnlock()
	return len(fake.withDebugArgsForCall)
}

func (fake *SessionClient) WithDebugArgsForCall(i int) io.Writer {
	fake.withDebugMutex.RLock()
	defer fake.withDebugMutex.RUnlock()
	return fake.withDebugArgsForCall[i].writer
}

func (fake *SessionClient) WithDebugReturns(result1 client.SessionClient) {
	fake.WithDebugStub = nil
	fake.withDebugReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithDebugReturnsOnCall(i int, result1 client.SessionClient) {
	fake.WithDebugStub = nil
	if fake.withDebugReturnsOnCall == nil {
		fake.withDebugReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withDebugReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithAuthToken(authToken string) client.SessionClient {
	fake.withAuthTokenMutex.Lock()
	ret, specificReturn := fake.withAuthTokenReturnsOnCall[len(fake.withAuthTokenArgsForCall)]
	fake.withAuthTokenArgsForCall = append(fake.withAuthTokenArgsForCall, struct {
		authToken string
	}{authToken})
	fake.recordInvocation("WithAuthToken", []interface{}{authToken})
	fake.withAuthTokenMutex.Unlock()
	if fake.WithAuthTokenStub != nil {
		return fake.WithAuthTokenStub(authToken)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.withAuthTokenReturns.result1
}

func (fake *SessionClient) WithAuthTokenCallCount() int {
	fake.withAuthTokenMutex.RLock()
	defer fake.withAuthTokenMutex.RUnlock()
	return len(fake.withAuthTokenArgsForCall)
}

func (fake *SessionClient) WithAuthTokenArgsForCall(i int) string {
	fake.withAuthTokenMutex.RLock()
	defer fake.withAuthTokenMutex.RUnlock()
	return fake.withAuthTokenArgsForCall[i].authToken
}

func (fake *SessionClient) WithAuthTokenReturns(result1 client.SessionClient) {
	fake.WithAuthTokenStub = nil
	fake.withAuthTokenReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithAuthTokenReturnsOnCall(i int, result1 client.SessionClient) {
	fake.WithAuthTokenStub = nil
	if fake.withAuthTokenReturnsOnCall == nil {
		fake.withAuthTokenReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withAuthTokenReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithPathParameter(name string, value string) client.SessionClient {
	fake.withPathParameterMutex.Lock()
	ret, specificReturn := fake.withPathParameterReturnsOnCall[len(fake.withPathParameterArgsForCall)]
	fake.withPathParameterArgsForCall = append(fake.withPathParameterArgsForCall, struct {
		name  string
		value string
	}{name, value})
	fake.recordInvocation("WithPathParameter", []interface{}{name, value})
	fake.withPathParameterMutex.Unlock()
	if fake.WithPathParameterStub != nil {
		return fake.WithPathParameterStub(name, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.withPathParameterReturns.result1
}

func (fake *SessionClient) WithPathParameterCallCount() int {
	fake.withPathParameterMutex.RLock()
	defer fake.withPathParameterMutex.RUnlock()
	return len(fake.withPathParameterArgsForCall)
}

func (fake *SessionClient) WithPathParameterArgsForCall(i int) (string, string) {
	fake.withPathParameterMutex.RLock()
	defer fake.withPathParameterMutex.RUnlock()
	return fake.withPathParameterArgsForCall[i].name, fake.withPathParameterArgsForCall[i].value
}

func (fake *SessionClient) WithPathParameterReturns(result1 client.SessionClient) {
	fake.WithPathParameterStub = nil
	fake.withPathParameterReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithPathParameterReturnsOnCall(i int, result1 client.SessionClient) {
	fake.WithPathParameterStub = nil
	if fake.withPathParameterReturnsOnCall == nil {
		fake.withPathParameterReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withPathParameterReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithQueryValue(name string, value string) client.SessionClient {
	fake.withQueryValueMutex.Lock()
	ret, specificReturn := fake.withQueryValueReturnsOnCall[len(fake.withQueryValueArgsForCall)]
	fake.withQueryValueArgsForCall = append(fake.withQueryValueArgsForCall, struct {
		name  string
		value string
	}{name, value})
	fake.recordInvocation("WithQueryValue", []interface{}{name, value})
	fake.withQueryValueMutex.Unlock()
	if fake.WithQueryValueStub != nil {
		return fake.WithQueryValueStub(name, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.withQueryValueReturns.result1
}

func (fake *SessionClient) WithQueryValueCallCount() int {
	fake.withQueryValueMutex.RLock()
	defer fake.withQueryValueMutex.RUnlock()
	return len(fake.withQueryValueArgsForCall)
}

func (fake *SessionClient) WithQueryValueArgsForCall(i int) (string, string) {
	fake.withQueryValueMutex.RLock()
	defer fake.withQueryValueMutex.RUnlock()
	return fake.withQueryValueArgsForCall[i].name, fake.withQueryValueArgsForCall[i].value
}

func (fake *SessionClient) WithQueryValueReturns(result1 client.SessionClient) {
	fake.WithQueryValueStub = nil
	fake.withQueryValueReturns = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) WithQueryValueReturnsOnCall(i int, result1 client.SessionClient) {
	fake.WithQueryValueStub = nil
	if fake.withQueryValueReturnsOnCall == nil {
		fake.withQueryValueReturnsOnCall = make(map[int]struct {
			result1 client.SessionClient
		})
	}
	fake.withQueryValueReturnsOnCall[i] = struct {
		result1 client.SessionClient
	}{result1}
}

func (fake *SessionClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newRequestMutex.RLock()
	defer fake.newRequestMutex.RUnlock()
	fake.withDebugMutex.RLock()
	defer fake.withDebugMutex.RUnlock()
	fake.withAuthTokenMutex.RLock()
	defer fake.withAuthTokenMutex.RUnlock()
	fake.withPathParameterMutex.RLock()
	defer fake.withPathParameterMutex.RUnlock()
	fake.withQueryValueMutex.RLock()
	defer fake.withQueryValueMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *SessionClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.SessionClient = new(SessionClient)
